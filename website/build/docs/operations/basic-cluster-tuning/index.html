<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-operations/basic-cluster-tuning">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.22">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131010415-1"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-131010415-1",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Apache Druid" href="/opensearch.xml">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css">
<link rel="stylesheet" href="/css/code-block-buttons.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
<script src="/js/code-block-buttons.js"></script><title data-rh="true">Basic cluster tuning | Apache Druid</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://druid.apache.org/img/druid_nav.png"><meta data-rh="true" name="twitter:image" content="https://druid.apache.org/img/druid_nav.png"><meta data-rh="true" property="og:url" content="https://druid.apache.org/docs/operations/basic-cluster-tuning"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Basic cluster tuning | Apache Druid"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://druid.apache.org/docs/operations/basic-cluster-tuning"><link data-rh="true" rel="alternate" href="https://druid.apache.org/docs/operations/basic-cluster-tuning" hreflang="en"><link data-rh="true" rel="alternate" href="https://druid.apache.org/docs/operations/basic-cluster-tuning" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://CPK9PMSCEY-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.f9da320f.css">
<link rel="preload" href="/assets/js/runtime~main.48cb3551.js" as="script">
<link rel="preload" href="/assets/js/main.fe95e508.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/druid_nav.png" alt="" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/druid_nav.png" alt="" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Apache Druid</b></a><a class="navbar__item navbar__link" href="/technology">Technology</a><a class="navbar__item navbar__link" href="/use-cases">Use Cases</a><a class="navbar__item navbar__link" href="/druid-powered">Powered By</a><a class="navbar__item navbar__link" href="/docs/design/index">Docs</a><a class="navbar__item navbar__link" href="/community/">Community</a><a href="https://www.apache.org" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Apache<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a class="navbar__item navbar__link" href="/downloads.html">Download</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/design/">Getting started</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/tutorials/tutorial-batch">Tutorials</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/design/architecture">Design</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/ingestion/">Ingestion</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/data-management/">Data management</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/querying/sql">Querying</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/configuration/">Configuration</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/operations/web-console">Operations</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/web-console">Web console</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/java">Java runtime</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operations/security-overview">Security</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/operations/basic-cluster-tuning">Performance tuning</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/operations/basic-cluster-tuning">Basic cluster tuning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/segment-optimization">Segment size optimization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/mixed-workloads">Mixed workloads</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/http-compression">HTTP compression</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/clean-metadata-store">Automated metadata cleanup</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operations/request-logging">Monitoring</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/api-reference">API reference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/high-availability">High availability</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/rolling-updates">Rolling updates</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/rule-configuration">Using rules to drop and retain data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operations/other-hadoop">Working with different versions of Apache Hadoop</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operations/dump-segment">Misc</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/development/overview">Development</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/misc/papers-and-talks">Misc</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/comparisons/druid-vs-elasticsearch">Hidden</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Operations</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Performance tuning</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Basic cluster tuning</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Basic cluster tuning</h1></header><p>This document provides basic guidelines for configuration properties and cluster architecture considerations related to performance tuning of an Apache Druid deployment.</p><p>Please note that this document provides general guidelines and rules-of-thumb: these are not absolute, universal rules for cluster tuning, and this introductory guide is not an exhaustive description of all Druid tuning properties, which are described in the <a href="/docs/configuration/">configuration reference</a>.</p><p>If you have questions on tuning Druid for specific use cases, or questions on configuration properties not covered in this guide, please ask the <a href="https://druid.apache.org/community/" target="_blank" rel="noopener noreferrer">Druid user mailing list or other community channels</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="process-specific-guidelines">Process-specific guidelines<a class="hash-link" href="#process-specific-guidelines" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="historical">Historical<a class="hash-link" href="#historical" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="heap-sizing">Heap sizing<a class="hash-link" href="#heap-sizing" title="Direct link to heading">​</a></h4><p>The biggest contributions to heap usage on Historicals are:</p><ul><li>Partial unmerged query results from segments</li><li>The stored maps for <a href="/docs/querying/lookups">lookups</a>.</li></ul><p>A general rule-of-thumb for sizing the Historical heap is <code>(0.5GiB * number of CPU cores)</code>, with an upper limit of ~24GiB.</p><p>This rule-of-thumb scales using the number of CPU cores as a convenient proxy for hardware size and level of concurrency (note: this formula is not a hard rule for sizing Historical heaps).</p><p>Having a heap that is too large can result in excessively long GC collection pauses, the ~24GiB upper limit is imposed to avoid this.</p><p>If caching is enabled on Historicals, the cache is stored on heap, sized by <code>druid.cache.sizeInBytes</code>.</p><p>Running out of heap on the Historicals can indicate misconfiguration or usage patterns that are overloading the cluster.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="lookups">Lookups<a class="hash-link" href="#lookups" title="Direct link to heading">​</a></h5><p>If you are using lookups, calculate the total size of the lookup maps being loaded.</p><p>Druid performs an atomic swap when updating lookup maps (both the old map and the new map will exist in heap during the swap), so the maximum potential heap usage from lookup maps will be (2 * total size of all loaded lookups).</p><p>Be sure to add <code>(2 * total size of all loaded lookups)</code> to your heap size in addition to the <code>(0.5GiB * number of CPU cores)</code> guideline.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="processing-threads-and-buffers">Processing Threads and Buffers<a class="hash-link" href="#processing-threads-and-buffers" title="Direct link to heading">​</a></h4><p>Please see the <a href="#processing-threads-buffers">General Guidelines for Processing Threads and Buffers</a> section for an overview of processing thread/buffer configuration.</p><p>On Historicals:</p><ul><li><code>druid.processing.numThreads</code> should generally be set to <code>(number of cores - 1)</code>: a smaller value can result in CPU underutilization, while going over the number of cores can result in unnecessary CPU contention.</li><li><code>druid.processing.buffer.sizeBytes</code> can be set to 500MiB.</li><li><code>druid.processing.numMergeBuffers</code>, a 1:4 ratio of  merge buffers to processing threads is a reasonable choice for general use.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="direct-memory-sizing">Direct Memory Sizing<a class="hash-link" href="#direct-memory-sizing" title="Direct link to heading">​</a></h4><p>The processing and merge buffers described above are direct memory buffers.</p><p>When a historical processes a query, it must open a set of segments for reading. This also requires some direct memory space, described in <a href="#segment-decompression">segment decompression buffers</a>.</p><p>A formula for estimating direct memory usage follows:</p><p>(<code>druid.processing.numThreads</code> + <code>druid.processing.numMergeBuffers</code> + 1) * <code>druid.processing.buffer.sizeBytes</code></p><p>The <code>+ 1</code> factor is a fuzzy estimate meant to account for the segment decompression buffers.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="connection-pool-sizing">Connection pool sizing<a class="hash-link" href="#connection-pool-sizing" title="Direct link to heading">​</a></h4><p>Please see the <a href="#connection-pool">General Connection Pool Guidelines</a> section for an overview of connection pool configuration.</p><p>For Historicals, <code>druid.server.http.numThreads</code> should be set to a value slightly higher than the sum of <code>druid.broker.http.numConnections</code> across all the Brokers in the cluster.</p><p>Tuning the cluster so that each Historical can accept 50 queries and 10 non-queries is a reasonable starting point.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="segment-cache-size">Segment Cache Size<a class="hash-link" href="#segment-cache-size" title="Direct link to heading">​</a></h4><p>For better query performance, do not allocate segment data to a Historical in excess of the system free memory.  When <code>free system memory</code> is greater than or equal to <code>druid.segmentCache.locations</code>, the more segment data the Historical can be held in the memory-mapped segment cache.</p><p>Druid uses the <code>druid.segmentCache.locations</code> to calculate the total segment data size assigned to a Historical. For some rarer use cases, you can override this behavior with <code>druid.server.maxSize</code> property.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="number-of-historicals">Number of Historicals<a class="hash-link" href="#number-of-historicals" title="Direct link to heading">​</a></h4><p>The number of Historicals needed in a cluster depends on how much data the cluster has. For good performance, you will want enough Historicals such that each Historical has a good (<code>free system memory</code> / total size of all <code>druid.segmentCache.locations</code>) ratio, as described in the segment cache size section above.</p><p>Having a smaller number of big servers is generally better than having a large number of small servers, as long as you have enough fault tolerance for your use case.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ssd-storage">SSD storage<a class="hash-link" href="#ssd-storage" title="Direct link to heading">​</a></h4><p>We recommend using SSDs for storage on the Historicals, as they handle segment data stored on disk.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="total-memory-usage">Total memory usage<a class="hash-link" href="#total-memory-usage" title="Direct link to heading">​</a></h4><p>To estimate total memory usage of the Historical under these guidelines:</p><ul><li>Heap: <code>(0.5GiB * number of CPU cores) + (2 * total size of lookup maps) + druid.cache.sizeInBytes</code></li><li>Direct Memory: <code>(druid.processing.numThreads + druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes</code></li></ul><p>The Historical will use any available free system memory (i.e., memory not used by the Historical JVM and heap/direct memory buffers or other processes on the system) for memory-mapping of segments on disk. For better query performance, you will want to ensure a good (<code>free system memory</code> / total size of all <code>druid.segmentCache.locations</code>) ratio so that a greater proportion of segments can be kept in memory.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="segment-sizes-matter">Segment sizes matter<a class="hash-link" href="#segment-sizes-matter" title="Direct link to heading">​</a></h4><p>Be sure to check out <a href="/docs/operations/segment-optimization">segment size optimization</a> to help tune your Historical processes for maximum performance.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="broker">Broker<a class="hash-link" href="#broker" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="heap-sizing-1">Heap sizing<a class="hash-link" href="#heap-sizing-1" title="Direct link to heading">​</a></h4><p>The biggest contributions to heap usage on Brokers are:</p><ul><li>Partial unmerged query results from Historicals and Tasks</li><li>The segment timeline: this consists of location information (which Historical/Task is serving a segment) for all currently <a href="/docs/design/architecture#segment-lifecycle">available</a> segments.</li><li>Cached segment metadata: this consists of metadata, such as per-segment schemas, for all currently available segments.</li></ul><p>The Broker heap requirements scale based on the number of segments in the cluster, and the total data size of the segments.</p><p>The heap size will vary based on data size and usage patterns, but 4GiB to 8GiB is a good starting point for a small or medium cluster (~15 servers or less). For a rough estimate of memory requirements on the high end, very large clusters with a node count on the order of ~100 nodes may need Broker heaps of 30GiB-60GiB.</p><p>If caching is enabled on the Broker, the cache is stored on heap, sized by <code>druid.cache.sizeInBytes</code>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="direct-memory-sizing-1">Direct memory sizing<a class="hash-link" href="#direct-memory-sizing-1" title="Direct link to heading">​</a></h4><p>On the Broker, the amount of direct memory needed depends on how many merge buffers (used for merging GroupBys) are configured. The Broker does not generally need processing threads or processing buffers, as query results are merged on-heap in the HTTP connection threads instead.</p><ul><li><code>druid.processing.buffer.sizeBytes</code> can be set to 500MiB.</li><li><code>druid.processing.numMergeBuffers</code>: set this to the same value as on Historicals or a bit higher</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="connection-pool-sizing-1">Connection pool sizing<a class="hash-link" href="#connection-pool-sizing-1" title="Direct link to heading">​</a></h4><p>Please see the <a href="#connection-pool">General Connection Pool Guidelines</a> section for an overview of connection pool configuration.</p><p>On the Brokers, please ensure that the sum of <code>druid.broker.http.numConnections</code> across all the Brokers is slightly lower than the value of <code>druid.server.http.numThreads</code> on your Historicals and Tasks.</p><p><code>druid.server.http.numThreads</code> on the Broker should be set to a value slightly higher than <code>druid.broker.http.numConnections</code> on the same Broker.</p><p>Tuning the cluster so that each Historical can accept 50 queries and 10 non-queries, adjusting the Brokers accordingly, is a reasonable starting point.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="broker-backpressure">Broker backpressure<a class="hash-link" href="#broker-backpressure" title="Direct link to heading">​</a></h4><p>When retrieving query results from Historical processes or Tasks, the Broker can optionally specify a maximum buffer size for queued, unread data, and exert backpressure on the channel to the Historical or Tasks when limit is reached (causing writes to the channel to block on the Historical/Task side until the Broker is able to drain some data from the channel).</p><p>This buffer size is controlled by the <code>druid.broker.http.maxQueuedBytes</code> setting.</p><p>The limit is divided across the number of Historicals/Tasks that a query would hit: suppose I have <code>druid.broker.http.maxQueuedBytes</code> set to 5MiB, and the Broker receives a query that needs to be fanned out to 2 Historicals. Each per-historical channel would get a 2.5MiB buffer in this case.</p><p>You can generally set this to a value of approximately <code>2MiB * number of Historicals</code>. As your cluster scales up with more Historicals and Tasks, consider increasing this buffer size and increasing the Broker heap accordingly.</p><ul><li>If the buffer is too small, this can lead to inefficient queries due to the buffer filling up rapidly and stalling the channel</li><li>If the buffer is too large, this puts more memory pressure on the Broker due to more queued result data in the HTTP channels.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="number-of-brokers">Number of brokers<a class="hash-link" href="#number-of-brokers" title="Direct link to heading">​</a></h4><p>A 1:15 ratio of Brokers to Historicals is a reasonable starting point (this is not a hard rule).</p><p>If you need Broker HA, you can deploy 2 initially and then use the 1:15 ratio guideline for additional Brokers.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="total-memory-usage-1">Total memory usage<a class="hash-link" href="#total-memory-usage-1" title="Direct link to heading">​</a></h4><p>To estimate total memory usage of the Broker under these guidelines:</p><ul><li>Heap: allocated heap size</li><li>Direct Memory: <code>(druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes</code></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="middlemanager">MiddleManager<a class="hash-link" href="#middlemanager" title="Direct link to heading">​</a></h3><p>The MiddleManager is a lightweight task controller/manager that launches Task processes, which perform ingestion work.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="middlemanager-heap-sizing">MiddleManager heap sizing<a class="hash-link" href="#middlemanager-heap-sizing" title="Direct link to heading">​</a></h4><p>The MiddleManager itself does not require much resources, you can set the heap to ~128MiB generally.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ssd-storage-1">SSD storage<a class="hash-link" href="#ssd-storage-1" title="Direct link to heading">​</a></h4><p>We recommend using SSDs for storage on the MiddleManagers, as the Tasks launched by MiddleManagers handle segment data stored on disk.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="task-count">Task Count<a class="hash-link" href="#task-count" title="Direct link to heading">​</a></h4><p>The number of tasks a MiddleManager can launch is controlled by the <code>druid.worker.capacity</code> setting.</p><p>The number of workers needed in your cluster depends on how many concurrent ingestion tasks you need to run for your use cases. The number of workers that can be launched on a given machine depends on the size of resources allocated per worker and available system resources.</p><p>You can allocate more MiddleManager machines to your cluster to add task capacity.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="task-configurations">Task configurations<a class="hash-link" href="#task-configurations" title="Direct link to heading">​</a></h4><p>The following section below describes configuration for Tasks launched by the MiddleManager. The Tasks can be queried and perform ingestion workloads, so they require more resources than the MM.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="task-heap-sizing">Task heap sizing<a class="hash-link" href="#task-heap-sizing" title="Direct link to heading">​</a></h5><p>A 1GiB heap is usually enough for Tasks.</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="lookups-1">Lookups<a class="hash-link" href="#lookups-1" title="Direct link to heading">​</a></h6><p>If you are using lookups, calculate the total size of the lookup maps being loaded.</p><p>Druid performs an atomic swap when updating lookup maps (both the old map and the new map will exist in heap during the swap), so the maximum potential heap usage from lookup maps will be (2 * total size of all loaded lookups).</p><p>Be sure to add <code>(2 * total size of all loaded lookups)</code> to your Task heap size if you are using lookups.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="task-processing-threads-and-buffers">Task processing threads and buffers<a class="hash-link" href="#task-processing-threads-and-buffers" title="Direct link to heading">​</a></h5><p>For Tasks, 1 or 2 processing threads are often enough, as the Tasks tend to hold much less queryable data than Historical processes.</p><ul><li><code>druid.indexer.fork.property.druid.processing.numThreads</code>: set this to 1 or 2</li><li><code>druid.indexer.fork.property.druid.processing.numMergeBuffers</code>: set this to 2</li><li><code>druid.indexer.fork.property.druid.processing.buffer.sizeBytes</code>: can be set to 100MiB</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="direct-memory-sizing-2">Direct memory sizing<a class="hash-link" href="#direct-memory-sizing-2" title="Direct link to heading">​</a></h5><p>The processing and merge buffers described above are direct memory buffers.</p><p>When a Task processes a query, it must open a set of segments for reading. This also requires some direct memory space, described in <a href="#segment-decompression">segment decompression buffers</a>.</p><p>An ingestion Task also needs to merge partial ingestion results, which requires direct memory space, described in <a href="#segment-merging">segment merging</a>.</p><p>A formula for estimating direct memory usage follows:</p><p>(<code>druid.processing.numThreads</code> + <code>druid.processing.numMergeBuffers</code> + 1) * <code>druid.processing.buffer.sizeBytes</code></p><p>The <code>+ 1</code> factor is a fuzzy estimate meant to account for the segment decompression buffers and dictionary merging buffers.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="connection-pool-sizing-2">Connection pool sizing<a class="hash-link" href="#connection-pool-sizing-2" title="Direct link to heading">​</a></h5><p>Please see the <a href="#connection-pool">General Connection Pool Guidelines</a> section for an overview of connection pool configuration.</p><p>For Tasks, <code>druid.server.http.numThreads</code> should be set to a value slightly higher than the sum of <code>druid.broker.http.numConnections</code> across all the Brokers in the cluster.</p><p>Tuning the cluster so that each Task can accept 50 queries and 10 non-queries is a reasonable starting point.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="total-memory-usage-2">Total memory usage<a class="hash-link" href="#total-memory-usage-2" title="Direct link to heading">​</a></h4><p>To estimate total memory usage of a Task under these guidelines:</p><ul><li>Heap: <code>1GiB + (2 * total size of lookup maps)</code></li><li>Direct Memory: <code>(druid.processing.numThreads + druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes</code></li></ul><p>The total memory usage of the MiddleManager + Tasks:</p><p><code>MM heap size + druid.worker.capacity * (single task memory usage)</code></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="configuration-guidelines-for-specific-ingestion-types">Configuration guidelines for specific ingestion types<a class="hash-link" href="#configuration-guidelines-for-specific-ingestion-types" title="Direct link to heading">​</a></h5><h6 class="anchor anchorWithStickyNavbar_LWe7" id="kafkakinesis-ingestion">Kafka/Kinesis ingestion<a class="hash-link" href="#kafkakinesis-ingestion" title="Direct link to heading">​</a></h6><p>If you use the <a href="/docs/development/extensions-core/kafka-ingestion">Kafka Indexing Service</a> or <a href="/docs/development/extensions-core/kinesis-ingestion">Kinesis Indexing Service</a>, the number of tasks required will depend on the number of partitions and your taskCount/replica settings.</p><p>On top of those requirements, allocating more task slots in your cluster is a good idea, so that you have free task
slots available for other tasks, such as <a href="/docs/data-management/compaction">compaction tasks</a>.</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="hadoop-ingestion">Hadoop ingestion<a class="hash-link" href="#hadoop-ingestion" title="Direct link to heading">​</a></h6><p>If you are only using <a href="/docs/ingestion/hadoop">Hadoop-based batch ingestion</a> with no other ingestion types, you can lower the amount of resources allocated per Task. Batch ingestion tasks do not need to answer queries, and the bulk of the ingestion workload will be executed on the Hadoop cluster, so the Tasks do not require much resources.</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="parallel-native-ingestion">Parallel native ingestion<a class="hash-link" href="#parallel-native-ingestion" title="Direct link to heading">​</a></h6><p>If you are using <a href="/docs/ingestion/native-batch">parallel native batch ingestion</a>, allocating more available task slots is a good idea and will allow greater ingestion concurrency.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="coordinator">Coordinator<a class="hash-link" href="#coordinator" title="Direct link to heading">​</a></h3><p>The main performance-related setting on the Coordinator is the heap size.</p><p>The heap requirements of the Coordinator scale with the number of servers, segments, and tasks in the cluster.</p><p>You can set the Coordinator heap to the same size as your Broker heap, or slightly smaller: both services have to process cluster-wide state and answer API requests about this state.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-configuration">Dynamic Configuration<a class="hash-link" href="#dynamic-configuration" title="Direct link to heading">​</a></h4><p><code>percentOfSegmentsToConsiderPerMove</code></p><ul><li>The default value is 100. This means that the Coordinator will consider all segments when it is looking for a segment to move. The Coordinator makes a weighted choice, with segments on Servers with the least capacity being the most likely segments to be moved.<ul><li>This weighted selection strategy means that the segments on the servers who have the most available capacity are the least likely to be chosen.</li><li>As the number of segments in the cluster increases, the probability of choosing the Nth segment to move decreases; where N is the last segment considered for moving.</li><li>An admin can use this config to skip consideration of that Nth segment.</li></ul></li><li>Instead of skipping a precise amount of segments, we skip a percentage of segments in the cluster.<ul><li>For example, with the value set to 25, only the first 25% of segments will be considered as a segment that can be moved. This 25% of segments will come from the servers that have the least available capacity.<ul><li>In this example, each time the Coordinator looks for a segment to move, it will consider 75% less segments than it did when the configuration was 100. On clusters with hundreds of thousands of segments, this can add up to meaningful coordination time savings.</li></ul></li></ul></li><li>General recommendations for this configuration:<ul><li>If you are not worried about the amount of time it takes your Coordinator to complete a full coordination cycle, you likely do not need to modify this config.</li><li>If you are frustrated with how long the Coordinator takes to run a full coordination cycle, and you have set the Coordinator dynamic config <code>maxSegmentsToMove</code> to a value above 0 (the default is 5), setting this config to a non-default value can help shorten coordination time.<ul><li>The recommended starting point value is 66. It represents a meaningful decrease in the percentage of segments considered while also not being too aggressive (You will consider 1/3 fewer segments per move operation with this value).</li></ul></li></ul></li><li>The impact that modifying this config will have on your coordination time will be a function of how low you set the config value, the value for <code>maxSegmentsToMove</code> and the total number of segments in your cluster.<ul><li>If your cluster has a relatively small number of segments, or you choose to move few segments per coordination cycle, there may not be much savings to be had here.</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="overlord">Overlord<a class="hash-link" href="#overlord" title="Direct link to heading">​</a></h3><p>The main performance-related setting on the Overlord is the heap size.</p><p>The heap requirements of the Overlord scale primarily with the number of running Tasks.</p><p>The Overlord tends to require less resources than the Coordinator or Broker. You can generally set the Overlord heap to a value that&#x27;s 25-50% of your Coordinator heap.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="router">Router<a class="hash-link" href="#router" title="Direct link to heading">​</a></h3><p>The Router has light resource requirements, as it proxies requests to Brokers without performing much computational work itself.</p><p>You can assign it 256MiB heap as a starting point, growing it if needed.</p><a name="processing-threads-buffers"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guidelines-for-processing-threads-and-buffers">Guidelines for processing threads and buffers<a class="hash-link" href="#guidelines-for-processing-threads-and-buffers" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="processing-threads">Processing threads<a class="hash-link" href="#processing-threads" title="Direct link to heading">​</a></h3><p>The <code>druid.processing.numThreads</code> configuration controls the size of the processing thread pool used for computing query results. The size of this pool limits how many queries can be concurrently processed.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="processing-buffers">Processing buffers<a class="hash-link" href="#processing-buffers" title="Direct link to heading">​</a></h3><p><code>druid.processing.buffer.sizeBytes</code> is a closely related property that controls the size of the off-heap buffers allocated to the processing threads.</p><p>One buffer is allocated for each processing thread. A size between 500MiB and 1GiB is a reasonable choice for general use.</p><p>The TopN and GroupBy queries use these buffers to store intermediate computed results. As the buffer size increases, more data can be processed in a single pass.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="groupby-merging-buffers">GroupBy merging buffers<a class="hash-link" href="#groupby-merging-buffers" title="Direct link to heading">​</a></h3><p>If you plan to issue GroupBy V2 queries, <code>druid.processing.numMergeBuffers</code> is an important configuration property.</p><p>GroupBy V2 queries use an additional pool of off-heap buffers for merging query results. These buffers have the same size as the processing buffers described above, set by the <code>druid.processing.buffer.sizeBytes</code> property.</p><p>Non-nested GroupBy V2 queries require 1 merge buffer per query, while a nested GroupBy V2 query requires 2 merge buffers (regardless of the depth of nesting).</p><p>The number of merge buffers determines the number of GroupBy V2 queries that can be processed concurrently.</p><a name="connection-pool"></a><h2 class="anchor anchorWithStickyNavbar_LWe7" id="connection-pool-guidelines">Connection pool guidelines<a class="hash-link" href="#connection-pool-guidelines" title="Direct link to heading">​</a></h2><p>Each Druid process has a configuration property for the number of HTTP connection handling threads, <code>druid.server.http.numThreads</code>.</p><p>The number of HTTP server threads limits how many concurrent HTTP API requests a given process can handle.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sizing-the-connection-pool-for-queries">Sizing the connection pool for queries<a class="hash-link" href="#sizing-the-connection-pool-for-queries" title="Direct link to heading">​</a></h3><p>The Broker has a setting <code>druid.broker.http.numConnections</code> that controls how many outgoing connections it can make to a given Historical or Task process.</p><p>These connections are used to send queries to the Historicals or Tasks, with one connection per query; the value of <code>druid.broker.http.numConnections</code> is effectively a limit on the number of concurrent queries that a given broker can process.</p><p>Suppose we have a cluster with 3 Brokers and <code>druid.broker.http.numConnections</code> is set to 10.</p><p>This means that each Broker in the cluster will open up to 10 connections to each individual Historical or Task (for a total of 30 incoming query connections per Historical/Task).</p><p>On the Historical/Task side, this means that <code>druid.server.http.numThreads</code> must be set to a value at least as high as the sum of <code>druid.broker.http.numConnections</code> across all the Brokers in the cluster.</p><p>In practice, you will want to allocate additional server threads for non-query API requests such as status checks; adding 10 threads for those is a good general guideline. Using the example with 3 Brokers in the cluster and <code>druid.broker.http.numConnections</code> set to 10, a value of 40 would be appropriate for <code>druid.server.http.numThreads</code> on Historicals and Tasks.</p><p>As a starting point, allowing for 50 concurrent queries (requests that read segment data from datasources) + 10 non-query requests (other requests like status checks) on Historicals and Tasks is reasonable (i.e., set <code>druid.server.http.numThreads</code> to 60 there), while sizing <code>druid.broker.http.numConnections</code> based on the number of Brokers in the cluster to fit within the 50 query connection limit per Historical/Task.</p><ul><li>If the connection pool across Brokers and Historicals/Tasks is too small, the cluster will be underutilized as there are too few concurrent query slots.</li><li>If the connection pool is too large, you may get out-of-memory errors due to excessive concurrent load, and increased resource contention.</li><li>The connection pool sizing matters most when you require QoS-type guarantees and use query priorities; otherwise, these settings can be more loosely configured.</li><li>If your cluster usage patterns are heavily biased towards a high number of small concurrent queries (where each query takes less than ~15ms), enlarging the connection pool can be a good idea.</li><li>The 50/10 general guideline here is a rough starting point, since different queries impose different amounts of load on the system. To size the connection pool more exactly for your cluster, you would need to know the execution times for your queries and ensure that the rate of incoming queries does not exceed your &quot;drain&quot; rate.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="per-segment-direct-memory-buffers">Per-segment direct memory buffers<a class="hash-link" href="#per-segment-direct-memory-buffers" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="segment-decompression">Segment decompression<a class="hash-link" href="#segment-decompression" title="Direct link to heading">​</a></h3><p>When opening a segment for reading during segment merging or query processing, Druid allocates a 64KiB off-heap decompression buffer for each column being read.</p><p>Thus, there is additional direct memory overhead of (64KiB <em> number of columns read per segment </em> number of segments read) when reading segments.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="segment-merging">Segment merging<a class="hash-link" href="#segment-merging" title="Direct link to heading">​</a></h3><p>In addition to the segment decompression overhead described above, when a set of segments are merged during ingestion, a direct buffer is allocated for every String typed column, for every segment in the set to be merged.</p><p>The size of these buffers are equal to the cardinality of the String column within its segment, times 4 bytes (the buffers store integers).</p><p>For example, if two segments are being merged, the first segment having a single String column with cardinality 1000, and the second segment having a String column with cardinality 500, the merge step would allocate (1000 + 500) * 4 = 6000 bytes of direct memory.</p><p>These buffers are used for merging the value dictionaries of the String column across segments. These &quot;dictionary merging buffers&quot; are independent of the &quot;merge buffers&quot; configured by <code>druid.processing.numMergeBuffers</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="general-recommendations">General recommendations<a class="hash-link" href="#general-recommendations" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="jvm-tuning">JVM tuning<a class="hash-link" href="#jvm-tuning" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="garbage-collection">Garbage Collection<a class="hash-link" href="#garbage-collection" title="Direct link to heading">​</a></h4><p>We recommend using the G1GC garbage collector:</p><p><code>-XX:+UseG1GC</code></p><p>Enabling process termination on out-of-memory errors is useful as well, since the process generally will not recover from such a state, and it&#x27;s better to restart the process:</p><p><code>-XX:+ExitOnOutOfMemoryError</code></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="other-generally-useful-jvm-flags">Other generally useful JVM flags<a class="hash-link" href="#other-generally-useful-jvm-flags" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Duser.timezone=UTC</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Dfile.encoding=UTF-8</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Djava.io.tmpdir=&lt;should not be volatile tmpfs and also has good read and write speed. Strongly recommended to avoid using NFS mount&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Dorg.jboss.logging.provider=slf4j</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Dnet.spy.log.LoggerImpl=net.spy.memcached.compat.log.SLF4JLogger</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Dlog4j.shutdownCallbackRegistry=org.apache.druid.common.config.Log4jShutdown</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Dlog4j.shutdownHookEnabled=true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+PrintGCDetails</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+PrintGCDateStamps</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+PrintGCTimeStamps</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+PrintGCApplicationStoppedTime</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+PrintGCApplicationConcurrentTime</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-Xloggc:/var/logs/druid/historical.gc.log</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+UseGCLogFileRotation</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:NumberOfGCLogFiles=50</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:GCLogFileSize=10m</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+ExitOnOutOfMemoryError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:+HeapDumpOnOutOfMemoryError</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:HeapDumpPath=/var/logs/druid/historical.hprof</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-XX:MaxDirectMemorySize=1g</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>Please note that the flag settings above represent sample, general guidelines only. Be careful to use values appropriate
for your specific scenario and be sure to test any changes in staging environments.</p></blockquote><p><code>ExitOnOutOfMemoryError</code> flag is only supported starting JDK 8u92 . For older versions, <code>-XX:OnOutOfMemoryError=&#x27;kill -9 %p&#x27;</code> can be used.</p><p><code>MaxDirectMemorySize</code> restricts JVM from allocating more than specified limit, by setting it to unlimited JVM restriction is lifted and OS level memory limits would still be effective. It&#x27;s still important to make sure that Druid is not configured to allocate more off-heap memory than your machine has available. Important settings here include <code>druid.processing.numThreads</code>, <code>druid.processing.numMergeBuffers</code>, and <code>druid.processing.buffer.sizeBytes</code>.</p><p>Additionally, for large JVM heaps, here are a few Garbage Collection efficiency guidelines that have been known to help in some cases.</p><ul><li>Mount /tmp on tmpfs. See <a href="http://www.evanjones.ca/jvm-mmap-pause.html" target="_blank" rel="noopener noreferrer">The Four Month Bug: JVM statistics cause garbage collection pauses</a>.</li><li>On Disk-IO intensive processes (e.g., Historical and MiddleManager), GC and Druid logs should be written to a different disk than where data is written.</li><li>Disable <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html" target="_blank" rel="noopener noreferrer">Transparent Huge Pages</a>.</li><li>Try disabling biased locking by using <code>-XX:-UseBiasedLocking</code> JVM flag. See <a href="https://dzone.com/articles/logging-stop-world-pauses-jvm" target="_blank" rel="noopener noreferrer">Logging Stop-the-world Pauses in JVM</a>.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-utc-timezone">Use UTC timezone<a class="hash-link" href="#use-utc-timezone" title="Direct link to heading">​</a></h3><p>We recommend using UTC timezone for all your events and across your hosts, not just for Druid, but for all data infrastructure. This can greatly mitigate potential query problems with inconsistent timezones. To query in a non-UTC timezone see <a href="/docs/querying/granularities#period-granularities">query granularities</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="system-configuration">System configuration<a class="hash-link" href="#system-configuration" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ssds">SSDs<a class="hash-link" href="#ssds" title="Direct link to heading">​</a></h4><p>SSDs are highly recommended for Historical, MiddleManager, and Indexer processes if you are not running a cluster that is entirely in memory. SSDs can greatly mitigate the time required to page data in and out of memory.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jbod-vs-raid">JBOD vs RAID<a class="hash-link" href="#jbod-vs-raid" title="Direct link to heading">​</a></h4><p>Historical processes store large number of segments on Disk and support specifying multiple paths for storing those. Typically, hosts have multiple disks configured with RAID which makes them look like a single disk to OS. RAID might have overheads specially if its not hardware controller based but software based. So, Historicals might get improved disk throughput with JBOD.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="swap-space">Swap space<a class="hash-link" href="#swap-space" title="Direct link to heading">​</a></h4><p>We recommend <em>not</em> using swap space for Historical, MiddleManager, and Indexer processes since due to the large number of memory mapped segment files can lead to poor and unpredictable performance.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="linux-limits">Linux limits<a class="hash-link" href="#linux-limits" title="Direct link to heading">​</a></h4><p>For Historical, MiddleManager, and Indexer processes (and for really large clusters, Broker processes), you might need to adjust some Linux system limits to account for a large number of open files, a large number of network connections, or a large number of memory mapped files.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="ulimit">ulimit<a class="hash-link" href="#ulimit" title="Direct link to heading">​</a></h5><p>The limit on the number of open files can be set permanently by editing <code>/etc/security/limits.conf</code>. This value should be substantially greater than the number of segment files that will exist on the server.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="max_map_count">max_map_count<a class="hash-link" href="#max_map_count" title="Direct link to heading">​</a></h5><p>Historical processes and to a lesser extent, MiddleManager and Indexer processes memory map segment files, so depending on the number of segments per server, <code>/proc/sys/vm/max_map_count</code> might also need to be adjusted. Depending on the variant of Linux, this might be done via <code>sysctl</code> by placing a file in <code>/etc/sysctl.d/</code> that sets <code>vm.max_map_count</code>.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/apache/druid/edit/master/docs/../docs/operations/basic-cluster-tuning.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2022-09-17T04:58:11.000Z">Sep 17, 2022</time></b> by <b>Gian Merlino</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/operations/tls-support"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">TLS support</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/operations/segment-optimization"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Segment size optimization</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#process-specific-guidelines" class="table-of-contents__link toc-highlight">Process-specific guidelines</a><ul><li><a href="#historical" class="table-of-contents__link toc-highlight">Historical</a></li><li><a href="#broker" class="table-of-contents__link toc-highlight">Broker</a></li><li><a href="#middlemanager" class="table-of-contents__link toc-highlight">MiddleManager</a></li><li><a href="#coordinator" class="table-of-contents__link toc-highlight">Coordinator</a></li><li><a href="#overlord" class="table-of-contents__link toc-highlight">Overlord</a></li><li><a href="#router" class="table-of-contents__link toc-highlight">Router</a></li></ul></li><li><a href="#guidelines-for-processing-threads-and-buffers" class="table-of-contents__link toc-highlight">Guidelines for processing threads and buffers</a><ul><li><a href="#processing-threads" class="table-of-contents__link toc-highlight">Processing threads</a></li><li><a href="#processing-buffers" class="table-of-contents__link toc-highlight">Processing buffers</a></li><li><a href="#groupby-merging-buffers" class="table-of-contents__link toc-highlight">GroupBy merging buffers</a></li></ul></li><li><a href="#connection-pool-guidelines" class="table-of-contents__link toc-highlight">Connection pool guidelines</a><ul><li><a href="#sizing-the-connection-pool-for-queries" class="table-of-contents__link toc-highlight">Sizing the connection pool for queries</a></li></ul></li><li><a href="#per-segment-direct-memory-buffers" class="table-of-contents__link toc-highlight">Per-segment direct memory buffers</a><ul><li><a href="#segment-decompression" class="table-of-contents__link toc-highlight">Segment decompression</a></li><li><a href="#segment-merging" class="table-of-contents__link toc-highlight">Segment merging</a></li></ul></li><li><a href="#general-recommendations" class="table-of-contents__link toc-highlight">General recommendations</a><ul><li><a href="#jvm-tuning" class="table-of-contents__link toc-highlight">JVM tuning</a></li><li><a href="#use-utc-timezone" class="table-of-contents__link toc-highlight">Use UTC timezone</a></li><li><a href="#system-configuration" class="table-of-contents__link toc-highlight">System configuration</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="/img/favicon.png" class="themedImage_ToTc themedImage--light_HNdA footer__logo"><img src="/img/favicon.png" class="themedImage_ToTc themedImage--dark_i4oU footer__logo"></div><div class="footer__copyright">Copyright © 2023 Apache Software Foundation</div></div></div></footer></div>
<script src="/assets/js/runtime~main.48cb3551.js"></script>
<script src="/assets/js/main.fe95e508.js"></script>
</body>
</html>